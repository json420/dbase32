:mod:`dbase32` Reference
========================

.. py:module:: dbase32
    :synopsis: base32-encoding with a sorted-order alphabet (for databases)


Functions
---------

.. function:: db32enc(data)

    Encode *data* as D-Base32 text.

    An ``str`` instance is returned:

    >>> db32enc(b'Bytes')
    'BCVQBSEM'

    *data* must be a ``bytes`` instance that meets the following condition::

        5 <= len(data) <= 60 and len(data) % 5 == 0


.. function:: db32dec(text)

    Decode D-Base32 *text*.

    A ``bytes`` instance is returned:

    >>> db32dec('BCVQBSEM')
    b'Bytes'

    *text* must be an ``str`` instance meets the following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    A ``ValueError`` is raised if *text* contains any letters not in the
    D-Base32 alphabet.


.. function:: isdb32(text)

    Return ``True`` if *text* contains a valid D-Base32 encoded ID.

    >>> isdb32('39AYA9AY')
    True
    >>> isdb32('27AZ27AZ')
    False

    This function will only return ``True`` if *text* contains only valid
    D-Base32 letters, and if *text* meets following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0


.. function:: check_db32(text)

    Raise a ``ValueError`` if *text* is not a valid D-Base32 encoded ID.

    This function will raise a ``ValueError`` if *text* contains any letters
    that aren't part of the D-Base32 alphabet.  For example:

    >>> check_db32('39AYA9AY')
    >>> check_db32('39AY27AZ')
    Traceback (most recent call last):
      ...
    ValueError: invalid D-Base32 letter: 2

    This function will likewise raise a ``ValueError`` if *text* doesn't meet
    the following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0


.. function:: random_id(numbytes=15)

    Return a random ID built from *numbytes* worth of entropy.

    The ID is returned as an ``str`` containing the D-Base32 encoded version:

    >>> random_id()
    'XM4OINLIPO6VVF549TWYNK89'
    >>> random_id(5)
    'V37E4B38'

    The random data is from ``os.urandom()``.


Constants
---------

A few handy constants:


.. data:: MAX_BIN_LEN

    Max length of binary data accepted for encoding

    >>> MAX_BIN_LEN = 60  # 480-bits


.. data:: MAX_BIN_LEN

    Max length of text data accepted for decoding

    >>> MAX_TXT_LEN = 96


.. data:: DB32ALPHABET

    >>> DB32ALPHABET = frozenset('3456789ABCDEFGHIJKLMNOPQRSTUVWXY')


.. data:: DB32_FORWARD

    The 32-entry forward-table for encoding D-Base32

    >>> DB32_FORWARD = '3456789ABCDEFGHIJKLMNOPQRSTUVWXY'


.. data:: DB32_REVERSE

    The 256-entry reverse-table for decoding D-Base32

    >>> DB32_REVERSE = tuple(...)


.. data:: RANDOM_BITS

    Size (in bits) of default random ID generated by :func:`random_id()`

    >>> RANDOM_BITS = 120


.. data:: RANDOM_BYTES

    Size (in bytes) of default random ID generated by :func:`random_id()`

    >>> RANDOM_BYTES = 15
