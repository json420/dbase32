:mod:`dbase32` API
==================

.. py:module:: dbase32
    :synopsis: base32-encoding with a sorted-order alphabet (for databases)


The :mod:`dbase32` API consists of just six functions:

    * For encoding and decoding, there is :func:`db32enc()` and :func:`db32dec()`

    * For validation, there is :func:`isdb32()` and :func:`check_db32()`

    * :func:`random_id()` generates Dbase32 encoded random IDs

    * :func:`time_id()` generates random IDs that will sort by timestamp

.. note::

    :func:`time_id()` was previously named ``log_id``; for backward
    compatibility there is a ``log_id`` alias for :func:`time_id()`, but this
    may be dropped at some point in the future.



Tutorial
--------

Encode a ``bytes`` instance with :func:`db32enc()`:

>>> from dbase32 import db32enc
>>> db32enc(b'binary foo')
'FCNPVRELI7J9FUUI'

Decode the resulting ``str`` instance with :func:`db32dec()`:

>>> from dbase32 import db32dec
>>> db32dec('FCNPVRELI7J9FUUI')
b'binary foo'

:func:`db32dec()` can also directly decode UTF-8 ``bytes``:

>>> db32dec(b'FCNPVRELI7J9FUUI')
b'binary foo'

Use :func:`isdb32()` to test whether you have a valid Dbase32 encoded ID.  It
will return ``True`` if the ID is valid:

>>> from dbase32 import isdb32
>>> isdb32('FCNPVRELI7J9FUUI')
True

And will return ``False`` if the ID contains invalid letters or is the wrong
length:

>>> isdb32('AAAAAAAA')
True
>>> isdb32('AAAAAAAZ')
False
>>> isdb32('AAAAAAA')
False

You can likewise use :func:`check_db32()` to validate an ID.  It will return
``None`` if the ID is valid:

>>> from dbase32 import check_db32
>>> check_db32('FCNPVRELI7J9FUUI')

And will raise a ``ValueError`` if the ID contains invalid letters or is the
wrong length:

>>> check_db32('AAAAAAAA')
>>> check_db32('AAAAAAAZ')
Traceback (most recent call last):
  ...
ValueError: invalid Dbase32 letter: Z
>>> check_db32('AAAAAAA')
Traceback (most recent call last):
  ...
ValueError: len(text) is 7, need 8 <= len(text) <= 96

When you don't need the decoded ID, it's faster to validate with
:func:`isdb32()` or :func:`check_db32()` than to validate with :func:`db32dec()`
and throw away the needlessly decoded value.

Use :func:`random_id()` to generate a Dbase32 encoded random ID.  By default it
returns a 120-bit (15-byte) ID, which will be 24 characters in length when
Dbase32 encoded:

>>> from dbase32 import random_id
>>> random_id()  # doctest: +SKIP
'UGT6U75VTJL8IRBBPRFONKOQ'

The *numbytes* keyword argument defaults to ``15``, but you can override this
to get an ID with a different length.  Typically you would only do this for
unit testing, for example to create a well-formed 240-bit (30-byte) Dmedia file
ID, which will be 48 characters in length when Dbase32 encoded:

>>> random_id(30)  # doctest: +SKIP
'AU8HC68B9IC6AY6B3NHWOGCI9VK4MTOUSFLWRD7TLQBC56MN'

:func:`random_id()` gets its random data from ``os.urandom()``.  This:

>>> _id = random_id(15)

Is equivalent to this:

>>> import os
>>> _id = db32enc(os.urandom(15))

Although note that the C implementation of :func:`random_id()` is faster than
the above because it does everything internally with no back-and-forth between
Python and C.

Lastly, use :func:`time_id()` to generate random IDs which will sort according
to their Unix timestamp with a one second granularity.

Similar to :func:`random_id()`, :func:`time_id()` returns a 120-bit (15-byte)
ID, which will be 24 characters in length when Dbase32 encoded.  The difference
is the first 4 bytes contain the Unix timestamp (32-bit unsigned big endian),
and the remaining 11 bytes are from ``os.urandom()``.

If you don't provide the *timestamp* argument, it will be automatically
generated by calling ``time.time()``:

>>> time_id()  # doctest: +SKIP
'DBFL77QDNXTGB7GB3JB9YCCK'

Or you can provide your own timestamp, for example to use a timestamp already
generated for another purpose:

>>> time_id(1234567890)  # doctest: +SKIP
'C9E38NQ89VDDM5DAI8NGWGN5'



Well-formed IDs
---------------

Dbase32 is not designed to encode arbitrary data.  Instead, it's designed only
to encode well-formed IDs like those used in `Dmedia`_ and `Novacut`_.

Unlike standard `RFC-3548 Base32`_ encoding, Dbase32 does *not* support
padding.  The binary data must always be a multiple of 40 bits (5 bytes) in
length.

Well-formed *data* to be encoded must meet the following condition::

    5 <= len(data) <= 60 and len(data) % 5 == 0

If this condition isn't met, :func:`db32enc()` will raise a ``ValueError``.

In addition to only containing letters in :data:`DB32ALPHABET`, well-formed
*text* to be decoded must meet the following condition::

    8 <= len(text) <= 96 and len(text) % 8 == 0

If this condition isn't met, both :func:`db32dec()` and :func:`check_db32()`
will raise a ``ValueError``.  Likewise, if this condition isn't met,
:func:`isdb32()` will return ``False``.



Security
--------

Dbase32 has a nice security property in that a well-formed Dbase32 ID *should*
be safe to use directly in filenames and URLs, without any special escaping or
extra validation. 

.. warning::

    Please don't assume that *valid* Dbase32 IDs are safe to use without
    escaping in all situations!  This Dbase32 security property has only been
    well considered in the context of filenames and URLs, so don't carelessly
    assume it applies elsewhere!

This is a central concern for the `Dmedia FileStore`_, where file IDs from
untrusted input are used to construct the full filenames by which data is read
from the file-system.  Without properly validating this untrusted input, the
``FileStore`` could easily be vulnerable to directory traversal attacks.

``dbase32`` is rather unique among base32 implementations in that its
high-performance validation functions allow you to check whether some encoded
text is well-formed without actually decoding it.

You should *never* trust the ``dbase32`` validation functions as your sole
security mechanism, but you're encouraged to use these validation functions
liberally.  In particular, it's a good idea to use both :func:`isdb32()` and
:func:`check_db32()` in different, independent security layers.  For example:

>>> isdb32('../very/naughty/')
False
>>> check_db32('../very/naughty/')
Traceback (most recent call last):
  ...
ValueError: invalid Dbase32 letter: .

The C implementations of these validation functions are *extremely* performant,
so don't let performance concerns stop you from using them!  For example, on a
2.8GHz Intel® Core™ i7-4900MQ, :func:`isdb32()` and :func:`check_db32()` are
each capable of over 10 million validations per second::

    $ python3 -m dbase32.benchmark
    dbase32: 1.0.0
    Python: 3.4.0rc3, x86_64, Linux (Ubuntu 14.04)
    data size: 30 bytes
    Encodes/second:
       2,799,549: base64.b64encode(data)
       7,321,593: _dbase32.db32enc(data)
          74,722: fallback.db32enc(data)
    Decodes/second:
       1,512,776: base64.b64decode(text_b64)
       7,483,122: _dbase32.db32dec(text_db32)
          69,053: fallback.db32dec(text_db32)
    Validations/second:
      10,545,821: _dbase32.isdb32(text_db32)
         553,746: fallback.isdb32(text_db32)
      10,488,811: _dbase32.check_db32(text_db32)
         512,207: fallback.check_db32(text_db32)
    Random IDs/second:
         489,403: os.urandom(15)
         478,284: _dbase32.random_id(15)
         486,841: _dbase32.time_id()



Functions
---------

.. function:: db32enc(data)

    Encode *data* as Dbase32 text.

    An ``str`` instance is returned:

    >>> db32enc(b'Bytes')
    'BCVQBSEM'

    *data* must be a ``bytes`` instance that meets the following condition::

        5 <= len(data) <= 60 and len(data) % 5 == 0

    If the above condition is not met, a ``ValueError`` is raised.


.. function:: db32dec(text)

    Decode Dbase32 *text*.

    A ``bytes`` instance is returned:

    >>> db32dec('BCVQBSEM')
    b'Bytes'

    *text* must be an ``str`` or ``bytes`` instance that meets the following
    condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If the above condition is not met, or if *text* contains any letters not
    in :data:`DB32ALPHABET`, a ``ValueError`` is raised.


.. function:: isdb32(text)

    Return ``True`` if *text* contains a valid Dbase32 encoded ID.

    >>> isdb32('39AYA9AY')
    True
    >>> isdb32('27AZ27AZ')
    False

    This function will only return ``True`` if *text* contains only letters
    in :data:`DB32ALPHABET`, and if *text* meets following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    Otherwise, ``False`` is returned.


.. function:: check_db32(text)

    Raise a ``ValueError`` if *text* is not a valid Dbase32 encoded ID.

    This function will raise a ``ValueError`` if *text* contains any letters
    that are not in :data:`DB32ALPHABET`.  For example:

    >>> check_db32('39AYA9AY')
    >>> check_db32('39AY27AZ')
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32 letter: 2

    This function will likewise raise a ``ValueError`` if *text* doesn't meet
    the following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If *text* is a valid Dbase32 ID, this function returns ``None``.


.. function:: random_id(numbytes=15)

    Return a Dbase32 encoded random ID.

    By default, a 120-bit (15-byte) ID is returned, which will be 24
    characters in length when Dbase32 encoded:

    >>> random_id()  # doctest: +SKIP
    'XM4OINLIPO6VVF549TWYNK89'

    If provided, *numbytes* must be an ``int`` such that::

        5 <= numbytes <= 60 and numbytes % 5 == 0

    The random data is from ``os.urandom()``.


.. function:: time_id(timestamp=-1)

    Return a Dbase32 encoded random ID that will sort according to timestamp.

    These IDs will sort in ascending order according to the Unix timestamp, with
    a one second granularity.

    Similar to :func:`random_id()`, this function returns a 120-bit (15-byte)
    ID, which will be 24 characters in length when Dbase32 encoded.

    The difference is the first 4 bytes of this ID are the time since the Unix
    Epoch in seconds, truncated a 32-bit unsigned integer (which wont overflow
    till the year 2106).  The remaining 11 bytes are from ``os.urandom()``.

    This function is aimed at event logging and similar scenarios where it's
    handy for the IDs to sort chronologically.

    If you provide the optional *timestamp* kwarg, that timestamp will be used.
    Otherwise the timestamp is built by calling ``time.time()``.



Constants
---------

A few handy constants:


.. data:: DB32ALPHABET

    An ``str`` with the Dbase32 alphabet.

    >>> DB32ALPHABET = '3456789ABCDEFGHIJKLMNOPQRSTUVWXY'


.. data:: MAX_BIN_LEN

    Max length of binary data that :func:`db32enc()` accepts for encoding.

    >>> MAX_BIN_LEN = 60  # 480 bits


.. data:: MAX_TXT_LEN

    Max length of text data that :func:`db32dec` accepts for decoding.

    >>> MAX_TXT_LEN = 96


.. data:: RANDOM_BITS

    Default size (in bits) of the *decoded* ID generated by :func:`random_id()`

    >>> RANDOM_BITS = 120


.. data:: RANDOM_BYTES

    Default size (in bytes) of the *decoded* ID generated by :func:`random_id()`

    >>> RANDOM_BYTES = 15


.. data:: RANDOM_B32LEN

    Default size (in characters) of the ID generated by :func:`random_id()`

    >>> RANDOM_B32LEN = 24



.. _`Dbase32`: https://launchpad.net/dbase32
.. _`RFC-3548 Base32`: http://tools.ietf.org/html/rfc4648
.. _`Novacut`: https://launchpad.net/novacut
.. _`Dmedia`: https://launchpad.net/dmedia
.. _`Dmedia FileStore`: https://launchpad.net/filestore
