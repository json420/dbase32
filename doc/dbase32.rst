:mod:`dbase32` API
==================

.. py:module:: dbase32
    :synopsis: base32-encoding with a sorted-order alphabet (for databases)


The :mod:`dbase32` API consists of just six functions:

    * For encoding and decoding, there is :func:`db32enc()` and :func:`db32dec()`

    * For validation, there is :func:`isdb32()` and :func:`check_db32()`

    * :func:`random_id()` generates Dbase32 encoded random IDs

    * :func:`log_id()` generates so called "monotonic" IDs that will sort by
      timestamp



Tutorial
--------

Encode a ``bytes`` instance with :func:`db32enc()`:

>>> from dbase32 import db32enc
>>> db32enc(b'binary foo')
'FCNPVRELI7J9FUUI'

Decode the resulting ``str`` instance with :func:`db32dec()`:

>>> from dbase32 import db32dec
>>> db32dec('FCNPVRELI7J9FUUI')
b'binary foo'

:func:`db32dec()` can also directly decode UTF-8 ``bytes``:

>>> db32dec(b'FCNPVRELI7J9FUUI')
b'binary foo'

Use :func:`isdb32()` to test whether you have a valid Dbase32 encoded ID.  It
will return ``True`` if the ID is valid:

>>> from dbase32 import isdb32
>>> isdb32('FCNPVRELI7J9FUUI')
True

And will return ``False`` if the ID contains invalid letters or is the wrong
length:

>>> isdb32('AAAAAAAA')
True
>>> isdb32('AAAAAAAZ')
False
>>> isdb32('AAAAAAA')
False

You can likewise use :func:`check_db32()` to validate an ID.  It will return
``None`` if the ID is valid:

>>> from dbase32 import check_db32
>>> check_db32('FCNPVRELI7J9FUUI')

And will raise a ``ValueError`` if the ID contains invalid letters or is the
wrong length:

>>> check_db32('AAAAAAAA')
>>> check_db32('AAAAAAAZ')
Traceback (most recent call last):
  ...
ValueError: invalid Dbase32 letter: Z
>>> check_db32('AAAAAAA')
Traceback (most recent call last):
  ...
ValueError: len(text) is 7, need 8 <= len(text) <= 96

When you don't need the decoded ID, it's faster to validate with
:func:`isdb32()` or :func:`check_db32()` than to validate with :func:`db32dec()`
and throw away the needlessly decoded value.

Use :func:`random_id()` to generate a Dbase32 encoded random ID.  By default it
returns a 120-bit (15-byte) ID, which will be 24 characters in length when
Dbase32 encoded:

>>> from dbase32 import random_id
>>> random_id()
'UGT6U75VTJL8IRBBPRFONKOQ'

The *numbytes* keyword argument defaults to ``15``, but you can override this
to get an ID with a different length.  Typically you would only do this for
unit testing, for example to create a well-formed 240-bit (30-byte) Dmedia file
ID, which will be 48 characters in length when Dbase32 encoded:

>>> random_id(30)
'AU8HC68B9IC6AY6B3NHWOGCI9VK4MTOUSFLWRD7TLQBC56MN'

:func:`random_id()` gets its random data from ``os.urandom()``.  This:

>>> _id = random_id(15)

Is equivalent to this:

>>> _id = db32enc(os.urandom(15))

Although note that the C implementation of :func:`random_id()` is faster than
the above because it does everything internally with no back-and-forth between
Python and C.

Lastly, use :func:`log_id()` to generate so called "monotonic" random IDs which
will sort according to their Unix timestamp with a one second granularity.

Similar to :func:`random_id()`, :func:`log_id()` returns a 120-bit (15-byte) ID,
which will be 24 characters in length when Dbase32 encoded.  The difference is
the first 4 bytes are time since the Unix Epoch in seconds, and the remaining 11
bytes are from ``os.urandom()``.

If you don't provide the *timestamp* argument, it will be automatically
generated by calling ``time.time()``:

>>> log_id()
'DBFL77QDNXTGB7GB3JB9YCCK'

Or you can provide your own timestamp, for example to use a timestamp already
generated for another purpose:

>>> log_id(1234567890)
'C9E38NQ89VDDM5DAI8NGWGN5'



Well-formed IDs
---------------

Dbase32 is not designed to encode arbitrary data.  Instead, it's designed only
to encode well-formed IDs like those used in `Dmedia`_ and `Novacut`_.

Unlike standard `RFC-3548 Base32`_ encoding, Dbase32 does *not* support
padding.  The binary data must always be a multiple of 40 bits (5 bytes) in
length.

Well-formed *data* to be encoded must meet the following condition::

    5 <= len(data) <= 60 and len(data) % 5 == 0

If this condition isn't met, :func:`db32enc()` will raise a ``ValueError``.

In addition to only containing letters in :data:`DB32ALPHABET`, well-formed
*text* to be decoded must meet the following condition::

    8 <= len(text) <= 96 and len(text) % 8 == 0

If this condition isn't met, both :func:`db32dec()` and :func:`check_db32()`
will raise a ``ValueError``.  Likewise, if this condition isn't met,
:func:`isdb32()` will return ``False``.



Functions
---------

.. function:: db32enc(data)

    Encode *data* as Dbase32 text.

    An ``str`` instance is returned:

    >>> db32enc(b'Bytes')
    'BCVQBSEM'

    *data* must be a ``bytes`` instance that meets the following condition::

        5 <= len(data) <= 60 and len(data) % 5 == 0

    If the above condition is not met, a ``ValueError`` is raised.


.. function:: db32dec(text)

    Decode Dbase32 *text*.

    A ``bytes`` instance is returned:

    >>> db32dec('BCVQBSEM')
    b'Bytes'

    *text* must be an ``str`` or ``bytes`` instance that meets the following
    condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If the above condition is not met, or if *text* contains any letters not
    in :data:`DB32ALPHABET`, a ``ValueError`` is raised.


.. function:: isdb32(text)

    Return ``True`` if *text* contains a valid Dbase32 encoded ID.

    >>> isdb32('39AYA9AY')
    True
    >>> isdb32('27AZ27AZ')
    False

    This function will only return ``True`` if *text* contains only letters
    in :data:`DB32ALPHABET`, and if *text* meets following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    Otherwise, ``False`` is returned.


.. function:: check_db32(text)

    Raise a ``ValueError`` if *text* is not a valid Dbase32 encoded ID.

    This function will raise a ``ValueError`` if *text* contains any letters
    that are not in :data:`DB32ALPHABET`.  For example:

    >>> check_db32('39AYA9AY')
    >>> check_db32('39AY27AZ')
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32 letter: 2

    This function will likewise raise a ``ValueError`` if *text* doesn't meet
    the following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If *text* is a valid Dbase32 ID, this function returns ``None``.


.. function:: random_id(numbytes=15)

    Return a Dbase32 encoded random ID.

    By default, a 120-bit (15-byte) ID is returned, which will be 24
    characters in length when Dbase32 encoded:

    >>> random_id()
    'XM4OINLIPO6VVF549TWYNK89'

    If provided, *numbytes* must be an ``int`` such that::

        5 <= numbytes <= 60 and numbytes % 5 == 0

    The random data is from ``os.urandom()``.


.. function:: log_id(timestamp=-1)

    Return a (generally) monotonic ID with 88 bits of random entropy.

    These IDs will sort in ascending order according to the Unix timestamp, with
    a one second granularity.

    Similar to :func:`random_id()`, this function returns a 120-bit (15-byte)
    ID, which will be 24 characters in length when Dbase32 encoded.

    The difference is the first 4 bytes of this ID are the time since the Unix
    Epoch in seconds, truncated a 32-bit unsigned integer (which wont overflow
    till the year 2106).  The remaining 11 bytes are from ``os.urandom()``.

    This ID function is aimed at event logging, where a (generally) monotonic ID
    will result in a b-tree that grows in a more space efficient manner.

    If you provide the optional *timestamp* kwarg, this timestamp will be used.
    Otherwise the timestamp is built by calling ``time.time()``.



Constants
---------

A few handy constants:


.. data:: DB32ALPHABET

    An ``str`` with the Dbase32 alphabet.

    >>> DB32ALPHABET = '3456789ABCDEFGHIJKLMNOPQRSTUVWXY'


.. data:: MAX_BIN_LEN

    Max length of binary data that :func:`db32enc()` accepts for encoding.

    >>> MAX_BIN_LEN = 60  # 480 bits


.. data:: MAX_TXT_LEN

    Max length of text data that :func:`db32dec` accepts for decoding.

    >>> MAX_TXT_LEN = 96


.. data:: RANDOM_BITS

    Default size (in bits) of the *decoded* ID generated by :func:`random_id()`

    >>> RANDOM_BITS = 120


.. data:: RANDOM_BYTES

    Default size (in bytes) of the *decoded* ID generated by :func:`random_id()`

    >>> RANDOM_BYTES = 15


.. data:: RANDOM_B32LEN

    Default size (in characters) of the ID generated by :func:`random_id()`

    >>> RANDOM_B32LEN = 24



.. _`Dbase32`: https://launchpad.net/dbase32
.. _`RFC-3548 Base32`: http://tools.ietf.org/html/rfc4648
.. _`Novacut`: https://launchpad.net/novacut
.. _`Dmedia`: https://launchpad.net/dmedia
